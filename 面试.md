### 公司方面

多了解数据签名、ca用证书加密这一块儿

### JavaSE

1、多线程+线程池

- 进程：数据集合上的运行活动，系统进行资源调配的基本单位
- 线程：进程的一个执行路径，多个线程共享进程的资源
- 并发：指同一个时间段内多任务执行。
- 并行：单位时间内多个任务同时进行

关于多线程：每个线程都有自己的私有内存，存入从主内存空间复制过来的变量。在有的计算器中，CPU的每个核都有自己的一级缓存，在所有的CPU下统一有个二级缓存。在二级缓存之后才是主内存。若线程A在两级缓存中都没有获取到值，就会到主内存取值。修改值后，先后在缓存和主内存中更换值。而对于另一个线程B，在主内存中获取到值进行修改后，线程A若再修改值会去缓存中获取A被修改的值，B修改后的值对A不可见。

对于Synchronized：将缓存清除，这样获取到的值直接从内存中获取。在结束Synchronized时将修改的时候也直接把修改后的值刷到主内存中。独占锁，降低并发性。

对于volatile：直接将修改后的变量刷到主内存中，读的时候也会去主内存中读。

创建线程：集成Thread，实现Runnable和Callable接口。

线程状态：NEW,RUNNABLE,BLOCKED,WAITING,TIME_WAITING,TERMINATED

线程池：ThreadPoolExecutor

```java
  public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
```

2、BIO+NIO

- BIO:

  - 输入流和输出流

  - 字节流和字符流：

    - 字节流：最小操作单位是8bit的字节流，一般以Stream结尾
    - 字符流：最小操作单位是16bit的字符流，一般以reader和writer结尾

  - 节点流和包装流

    - 节点流：偏向实现细节，譬如FileInputStream

    - 包装流：偏向功能实现

      区分：节点流一般构造方法传入具体的物理节点，而包装流需要一个流对象。

![这里写图片描述](E:\Java笔记\图片\S1outhEast.jpg)

3、集合

- 键值对的存储位置：key的hashCode方法加高位（h = h.hashCode() ^(h>>>16)）运算和取模运算,在重新计算hash时，由于length变成2倍，所以会增加个bit位，若该bit为0索引位置不变，为1时索引位置+oldlength
- 数组+链表--->数组+红黑树（链表长度==8），默认初始容量是16

4、lambda + Stream流式计算

### MySQL

1、调优

2、了解事务

### NoSQL

1、redis的基本使用

### Spring

#### Spring底层

1、Bean的加载和生命周期

- **解析加载**：为了加载多个xml文件，会创建一个Applicationcontext的实例.将文件路径传入ApplicationContext构造器。而beanFactory通过 bean definition reader从多个文件中读取bean定义。
- **getBean：**
  - **获取BeanName**，对传入的name进行解析，转为可以从Map获取到BeanDefinition的beanName。
  - **合并Bean定义**，对父类的定义进行合并与覆盖，若父类仍有父类进行递归合并，获取完整的Bean定义信息。
  - **实例化，**使用构造或者工厂创建Bean实例
  - **属性填充，**注入依赖，依赖的Bena会递归调用getBean方法获取
  - **获取最终的Bean：**若是FactoryBean需要调用getObject方法，若是需要类型转换调用TypeConverter进行转化
- **生命周期：**
  1. spring启动，查找加载Bean，进行Bean的实例化。
  2. 实例化后将Bean的引入和值注入到Bean的属性当中。
  3. 接着看Bean实现那些接口，spring调用对应的接口。
  4. 等待被使用直至应用上下文被销毁

2、IOC+AOP

- IOC，

  - DI注入：Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。
  - @autowired类型自动装配，若是需要名称的话加上@Qualifier("adminService")

- AOP

  - 切面(Aspect)：共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。

  - 通知(Advice)：：切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。

  - 连接点(JoinPoint):程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。

  - 切入点

    ```java
    @Pointcut("execution(public * cn.wbnull.springbootdemo.controller.*.*(..))")
    private void sign() {
     
    }
    ```

  ```java
  
  @Aspect
  @Component
  public class SignAop {
   
      @Pointcut("execution(public * cn.wbnull.springbootdemo.controller.*.*(..))")
      private void signAop() {
   
      }
   
      @Before("signAop()")
      public void doBefore(JoinPoint joinPoint) throws Exception {
          //code
         }
   
      @AfterReturning(value = "signAop()", returning = "params")
      public JSONObject doAfterReturning(JoinPoint joinPoint, JSONObject params) {
          //code
          }
  
  ```

  

3、DI，注入方式

4、Spring事务

- 事务特性：ACID
  - 原子性(Atomicity)：事务是一个原子操作，有一系列动作完成，保证要么全部完成，要么不起作用。
  - 一致性(Consistency)：事务完成(无论成功还是失败)，必须保证整个系统的业务一直，不能部分完成，显示数据不可被破坏。
  - 隔离性(Isolation)：会有许多事务处理相同的数据，每个事务应该互相隔离，防止数据损坏.
  - 持久性(Durability):事务完成后，无论系统发生什么错误，其结果都不该再受影响
- 事务的配置方式：编程式事务、声明式事务
  - 编程式事务，侵入式事务，推荐使用TransactionTemplate
  - 声明式事务，建立在AOP基础之上，在方法开始之前创建或加入一个事务，无侵入式事务
- 事务的传播机制：一般用于在事务的嵌套之中
- 事务的隔离级别：
  - ISOLATION_DEFAULT:默认的隔离级别
  - ISOLATION_READ_UNCOMMITED：未提交读，导致脏读、幻读或不可重复读
  - ISOLATION_REEAD_COMMITED(ORACLE)：防止脏读，幻读、不可重复读
  - ISOLATION_REPEATABLE_READ:防止脏读和不可重复读，幻读仍可能发生
  - ISOLATION_SERIALIZABLE：完全服从ACID原则，但是速度很慢

5、动态代理

- 动态代理实现InvocationHandler接口，实现invoke方法

#### SpringMVC

1、运行流程

- 用户发送请求至前端控制器DispatcherServlet
- DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取处理；
- 处理器映射器根据url找到具体的处理器，生成处理器对象和处理器拦截器一并返回DispatcherServlet
- DispatcherServlet调用HandlerAdapter处理器适配器
- HandlerAdapter经过适配调用具体的处理器(Controller，及后端控制器)；
- Controller执行完成返回ModelAndView；
- HandlerAdapter将controller执行结果ModelView返回给DispatcherServlet
- DispatcherServlet将ModelAndView传给ViewResolver视图解析器；
- viewResolver解析后返回具体View
- DispatcherServlet根据View进行视图渲染。
- DispatcherServlet响应用户



#### SpringBoot

1、自动装配

- 以springboot来讲

  > @SpringbootApplication ->@EnableAutoConfiguration-> @Import({AutoConfigurationImportSelector.class})->getCandidateConfiguration
  >
  > ->SpringFactories.loadFactoryName->loadSpringFactories(其中getResource
  >
  > spring.factories)

- 以HttpEncodingAutoConfiguration（Http编码自动配置）

  ```java
  //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
  @Configuration 
  
  //启动指定类的ConfigurationProperties功能；
    //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
    //并把HttpProperties加入到ioc容器中
  @EnableConfigurationProperties({HttpProperties.class}) 
  
  //Spring底层@Conditional注解
    //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
    //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
  @ConditionalOnWebApplication(
      type = Type.SERVLET
  )
  
  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
  @ConditionalOnClass({CharacterEncodingFilter.class})
  
  //判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
    //如果不存在，判断也是成立的
    //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
  @ConditionalOnProperty(
      prefix = "spring.http.encoding",
      value = {"enabled"},
      matchIfMissing = true
  )
  
  public class HttpEncodingAutoConfiguration {
      //他已经和SpringBoot的配置文件映射了
      private final Encoding properties;
      //只有一个有参构造器的情况下，参数的值就会从容器中拿
      public HttpEncodingAutoConfiguration(HttpProperties properties) {
          this.properties = properties.getEncoding();
      }
      
      //给容器中添加一个组件，这个组件的某些值需要从properties中获取
      @Bean
      @ConditionalOnMissingBean //判断容器没有这个组件？
      public CharacterEncodingFilter characterEncodingFilter() {
          CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
          filter.setEncoding(this.properties.getCharset().name());
          filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
          filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
          return filter;
      }
      //。。。。。。。
  }
  ```

  **即根据不同的条件判断，决定这个配置是否生效**

  - 一旦配置类生效，该配置类会给容器中添加各种组件
  - 这些组件属性是从对应的properties中获取的，该类的每个属性都是个配置文件绑定的
  - 所有配置文件中能配置的属性都在xxxProperties类中封存。
  - **xxxAutoConfiguration：自动配置类；给容器中添加组件**
  - **xxxProperties：封装配置文件相关属性**

- @Confition派生注解

  必须是@Conditional指定的条件成立，才向容器中添加组件。

  ![微信图片_20210622105309](E:\Java笔记\图片\微信图片_20210622105309.jpg)

  可以通过启用debug=true属性，让控制台打印自动配置报告。

  > Positive matches:自动配置类启用的
  >
  > Negative matches:没有启动
  >
  > Unconditional classes：没有条件的类

2、自定义starter

​	

#### SpringCloud

1、微服务和SOA

2、Eureka服务发现与注册

3、Ribbon、Fiegn负载均衡

4、Zuul路由网关

